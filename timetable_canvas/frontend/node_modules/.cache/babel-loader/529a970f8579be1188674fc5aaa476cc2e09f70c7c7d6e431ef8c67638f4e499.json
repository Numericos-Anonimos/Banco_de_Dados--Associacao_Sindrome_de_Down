{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { Int } from './int.mjs';\n/**\r\n * Compressed Sparse Fiber (CSF) sparse tensor index.\r\n */\nexport class SparseTensorIndexCSF {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsSparseTensorIndexCSF(bb, obj) {\n    return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  /**\r\n   * CSF is a generalization of compressed sparse row (CSR) index.\r\n   * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)\r\n   *\r\n   * CSF index recursively compresses each dimension of a tensor into a set\r\n   * of prefix trees. Each path from a root to leaf forms one tensor\r\n   * non-zero index. CSF is implemented with two arrays of buffers and one\r\n   * arrays of integers.\r\n   *\r\n   * For example, let X be a 2x3x4x5 tensor and let it have the following\r\n   * 8 non-zero values:\r\n   * ```text\r\n   *   X[0, 0, 0, 1] := 1\r\n   *   X[0, 0, 0, 2] := 2\r\n   *   X[0, 1, 0, 0] := 3\r\n   *   X[0, 1, 0, 2] := 4\r\n   *   X[0, 1, 1, 0] := 5\r\n   *   X[1, 1, 1, 0] := 6\r\n   *   X[1, 1, 1, 1] := 7\r\n   *   X[1, 1, 1, 2] := 8\r\n   * ```\r\n   * As a prefix tree this would be represented as:\r\n   * ```text\r\n   *         0          1\r\n   *        / \\         |\r\n   *       0   1        1\r\n   *      /   / \\       |\r\n   *     0   0   1      1\r\n   *    /|  /|   |    /| |\r\n   *   1 2 0 2   0   0 1 2\r\n   * ```\r\n   * The type of values in indptrBuffers\r\n   */\n  indptrType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\r\n   * indptrBuffers stores the sparsity structure.\r\n   * Each two consecutive dimensions in a tensor correspond to a buffer in\r\n   * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`\r\n   * and `indptrBuffers[dim][i + 1]` signify a range of nodes in\r\n   * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.\r\n   *\r\n   * For example, the indptrBuffers for the above X is:\r\n   * ```text\r\n   *   indptrBuffer(X) = [\r\n   *                       [0, 2, 3],\r\n   *                       [0, 1, 3, 4],\r\n   *                       [0, 2, 4, 5, 8]\r\n   *                     ].\r\n   * ```\r\n   */\n  indptrBuffers(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? (obj || new Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n  }\n  indptrBuffersLength() {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\r\n   * The type of values in indicesBuffers\r\n   */\n  indicesType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\r\n   * indicesBuffers stores values of nodes.\r\n   * Each tensor dimension corresponds to a buffer in indicesBuffers.\r\n   * For example, the indicesBuffers for the above X is:\r\n   * ```text\r\n   *   indicesBuffer(X) = [\r\n   *                        [0, 1],\r\n   *                        [0, 1, 1],\r\n   *                        [0, 0, 1, 1],\r\n   *                        [1, 2, 0, 2, 0, 0, 1, 2]\r\n   *                      ].\r\n   * ```\r\n   */\n  indicesBuffers(index, obj) {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? (obj || new Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;\n  }\n  indicesBuffersLength() {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\r\n   * axisOrder stores the sequence in which dimensions were traversed to\r\n   * produce the prefix tree.\r\n   * For example, the axisOrder for the above X is:\r\n   * ```text\r\n   *   axisOrder(X) = [0, 1, 2, 3].\r\n   * ```\r\n   */\n  axisOrder(index) {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;\n  }\n  axisOrderLength() {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  axisOrderArray() {\n    const offset = this.bb.__offset(this.bb_pos, 12);\n    return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;\n  }\n  static startSparseTensorIndexCSF(builder) {\n    builder.startObject(5);\n  }\n  static addIndptrType(builder, indptrTypeOffset) {\n    builder.addFieldOffset(0, indptrTypeOffset, 0);\n  }\n  static addIndptrBuffers(builder, indptrBuffersOffset) {\n    builder.addFieldOffset(1, indptrBuffersOffset, 0);\n  }\n  static startIndptrBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addIndicesType(builder, indicesTypeOffset) {\n    builder.addFieldOffset(2, indicesTypeOffset, 0);\n  }\n  static addIndicesBuffers(builder, indicesBuffersOffset) {\n    builder.addFieldOffset(3, indicesBuffersOffset, 0);\n  }\n  static startIndicesBuffersVector(builder, numElems) {\n    builder.startVector(16, numElems, 8);\n  }\n  static addAxisOrder(builder, axisOrderOffset) {\n    builder.addFieldOffset(4, axisOrderOffset, 0);\n  }\n  static createAxisOrderVector(builder, data) {\n    builder.startVector(4, data.length, 4);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt32(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startAxisOrderVector(builder, numElems) {\n    builder.startVector(4, numElems, 4);\n  }\n  static endSparseTensorIndexCSF(builder) {\n    const offset = builder.endObject();\n    builder.requiredField(offset, 4); // indptrType\n    builder.requiredField(offset, 6); // indptrBuffers\n    builder.requiredField(offset, 8); // indicesType\n    builder.requiredField(offset, 10); // indicesBuffers\n    builder.requiredField(offset, 12); // axisOrder\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","Buffer","Int","SparseTensorIndexCSF","constructor","bb","bb_pos","__init","i","getRootAsSparseTensorIndexCSF","obj","readInt32","position","getSizePrefixedRootAsSparseTensorIndexCSF","setPosition","SIZE_PREFIX_LENGTH","indptrType","offset","__offset","__indirect","indptrBuffers","index","__vector","indptrBuffersLength","__vector_len","indicesType","indicesBuffers","indicesBuffersLength","axisOrder","axisOrderLength","axisOrderArray","Int32Array","bytes","buffer","byteOffset","startSparseTensorIndexCSF","builder","startObject","addIndptrType","indptrTypeOffset","addFieldOffset","addIndptrBuffers","indptrBuffersOffset","startIndptrBuffersVector","numElems","startVector","addIndicesType","indicesTypeOffset","addIndicesBuffers","indicesBuffersOffset","startIndicesBuffersVector","addAxisOrder","axisOrderOffset","createAxisOrderVector","data","length","addInt32","endVector","startAxisOrderVector","endSparseTensorIndexCSF","endObject","requiredField"],"sources":["C:\\Users\\emclulo\\Downloads\\GitHub\\Banco_de_Dados--Associacao_Sindrome_de_Down\\timetable_canvas\\frontend\\node_modules\\apache-arrow\\src\\fb\\sparse-tensor-index-c-s-f.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport * as flatbuffers from 'flatbuffers';\r\n\r\nimport { Buffer } from './buffer.js';\r\nimport { Int } from './int.js';\r\n\r\n\r\n/**\r\n * Compressed Sparse Fiber (CSF) sparse tensor index.\r\n */\r\nexport class SparseTensorIndexCSF {\r\n  bb: flatbuffers.ByteBuffer|null = null;\r\n  bb_pos = 0;\r\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseTensorIndexCSF {\r\n  this.bb_pos = i;\r\n  this.bb = bb;\r\n  return this;\r\n}\r\n\r\nstatic getRootAsSparseTensorIndexCSF(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCSF):SparseTensorIndexCSF {\r\n  return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\nstatic getSizePrefixedRootAsSparseTensorIndexCSF(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCSF):SparseTensorIndexCSF {\r\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\r\n  return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\r\n}\r\n\r\n/**\r\n * CSF is a generalization of compressed sparse row (CSR) index.\r\n * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)\r\n *\r\n * CSF index recursively compresses each dimension of a tensor into a set\r\n * of prefix trees. Each path from a root to leaf forms one tensor\r\n * non-zero index. CSF is implemented with two arrays of buffers and one\r\n * arrays of integers.\r\n *\r\n * For example, let X be a 2x3x4x5 tensor and let it have the following\r\n * 8 non-zero values:\r\n * ```text\r\n *   X[0, 0, 0, 1] := 1\r\n *   X[0, 0, 0, 2] := 2\r\n *   X[0, 1, 0, 0] := 3\r\n *   X[0, 1, 0, 2] := 4\r\n *   X[0, 1, 1, 0] := 5\r\n *   X[1, 1, 1, 0] := 6\r\n *   X[1, 1, 1, 1] := 7\r\n *   X[1, 1, 1, 2] := 8\r\n * ```\r\n * As a prefix tree this would be represented as:\r\n * ```text\r\n *         0          1\r\n *        / \\         |\r\n *       0   1        1\r\n *      /   / \\       |\r\n *     0   0   1      1\r\n *    /|  /|   |    /| |\r\n *   1 2 0 2   0   0 1 2\r\n * ```\r\n * The type of values in indptrBuffers\r\n */\r\nindptrType(obj?:Int):Int|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 4);\r\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\n/**\r\n * indptrBuffers stores the sparsity structure.\r\n * Each two consecutive dimensions in a tensor correspond to a buffer in\r\n * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`\r\n * and `indptrBuffers[dim][i + 1]` signify a range of nodes in\r\n * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.\r\n *\r\n * For example, the indptrBuffers for the above X is:\r\n * ```text\r\n *   indptrBuffer(X) = [\r\n *                       [0, 2, 3],\r\n *                       [0, 1, 3, 4],\r\n *                       [0, 2, 4, 5, 8]\r\n *                     ].\r\n * ```\r\n */\r\nindptrBuffers(index: number, obj?:Buffer):Buffer|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? (obj || new Buffer()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;\r\n}\r\n\r\nindptrBuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 6);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\n/**\r\n * The type of values in indicesBuffers\r\n */\r\nindicesType(obj?:Int):Int|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 8);\r\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\r\n}\r\n\r\n/**\r\n * indicesBuffers stores values of nodes.\r\n * Each tensor dimension corresponds to a buffer in indicesBuffers.\r\n * For example, the indicesBuffers for the above X is:\r\n * ```text\r\n *   indicesBuffer(X) = [\r\n *                        [0, 1],\r\n *                        [0, 1, 1],\r\n *                        [0, 0, 1, 1],\r\n *                        [1, 2, 0, 2, 0, 0, 1, 2]\r\n *                      ].\r\n * ```\r\n */\r\nindicesBuffers(index: number, obj?:Buffer):Buffer|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? (obj || new Buffer()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 16, this.bb!) : null;\r\n}\r\n\r\nindicesBuffersLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 10);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\n/**\r\n * axisOrder stores the sequence in which dimensions were traversed to\r\n * produce the prefix tree.\r\n * For example, the axisOrder for the above X is:\r\n * ```text\r\n *   axisOrder(X) = [0, 1, 2, 3].\r\n * ```\r\n */\r\naxisOrder(index: number):number|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\r\n}\r\n\r\naxisOrderLength():number {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\r\n}\r\n\r\naxisOrderArray():Int32Array|null {\r\n  const offset = this.bb!.__offset(this.bb_pos, 12);\r\n  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;\r\n}\r\n\r\nstatic startSparseTensorIndexCSF(builder:flatbuffers.Builder) {\r\n  builder.startObject(5);\r\n}\r\n\r\nstatic addIndptrType(builder:flatbuffers.Builder, indptrTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(0, indptrTypeOffset, 0);\r\n}\r\n\r\nstatic addIndptrBuffers(builder:flatbuffers.Builder, indptrBuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(1, indptrBuffersOffset, 0);\r\n}\r\n\r\nstatic startIndptrBuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(16, numElems, 8);\r\n}\r\n\r\nstatic addIndicesType(builder:flatbuffers.Builder, indicesTypeOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(2, indicesTypeOffset, 0);\r\n}\r\n\r\nstatic addIndicesBuffers(builder:flatbuffers.Builder, indicesBuffersOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(3, indicesBuffersOffset, 0);\r\n}\r\n\r\nstatic startIndicesBuffersVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(16, numElems, 8);\r\n}\r\n\r\nstatic addAxisOrder(builder:flatbuffers.Builder, axisOrderOffset:flatbuffers.Offset) {\r\n  builder.addFieldOffset(4, axisOrderOffset, 0);\r\n}\r\n\r\nstatic createAxisOrderVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;\r\n/**\r\n * @deprecated This Uint8Array overload will be removed in the future.\r\n */\r\nstatic createAxisOrderVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;\r\nstatic createAxisOrderVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {\r\n  builder.startVector(4, data.length, 4);\r\n  for (let i = data.length - 1; i >= 0; i--) {\r\n    builder.addInt32(data[i]!);\r\n  }\r\n  return builder.endVector();\r\n}\r\n\r\nstatic startAxisOrderVector(builder:flatbuffers.Builder, numElems:number) {\r\n  builder.startVector(4, numElems, 4);\r\n}\r\n\r\nstatic endSparseTensorIndexCSF(builder:flatbuffers.Builder):flatbuffers.Offset {\r\n  const offset = builder.endObject();\r\n  builder.requiredField(offset, 4) // indptrType\r\n  builder.requiredField(offset, 6) // indptrBuffers\r\n  builder.requiredField(offset, 8) // indicesType\r\n  builder.requiredField(offset, 10) // indicesBuffers\r\n  builder.requiredField(offset, 12) // axisOrder\r\n  return offset;\r\n}\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}