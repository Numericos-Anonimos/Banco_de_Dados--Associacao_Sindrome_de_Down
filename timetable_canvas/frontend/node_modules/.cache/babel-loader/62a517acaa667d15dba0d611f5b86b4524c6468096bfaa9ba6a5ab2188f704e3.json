{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { valueToString } from '../util/pretty.mjs';\nimport { instance as getVisitor } from '../visitor/get.mjs';\nimport { instance as setVisitor } from '../visitor/set.mjs';\n/** @ignore */\nconst kParent = Symbol.for('parent');\n/** @ignore */\nconst kRowIndex = Symbol.for('rowIndex');\nexport class StructRow {\n  constructor(parent, rowIndex) {\n    this[kParent] = parent;\n    this[kRowIndex] = rowIndex;\n    return new Proxy(this, new StructRowProxyHandler());\n  }\n  toArray() {\n    return Object.values(this.toJSON());\n  }\n  toJSON() {\n    const i = this[kRowIndex];\n    const parent = this[kParent];\n    const keys = parent.type.children;\n    const json = {};\n    for (let j = -1, n = keys.length; ++j < n;) {\n      json[keys[j].name] = getVisitor.visit(parent.children[j], i);\n    }\n    return json;\n  }\n  toString() {\n    return \"{\".concat([...this].map(_ref => {\n      let [key, val] = _ref;\n      return \"\".concat(valueToString(key), \": \").concat(valueToString(val));\n    }).join(', '), \"}\");\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.toString();\n  }\n  [Symbol.iterator]() {\n    return new StructRowIterator(this[kParent], this[kRowIndex]);\n  }\n}\nclass StructRowIterator {\n  constructor(data, rowIndex) {\n    this.childIndex = 0;\n    this.children = data.children;\n    this.rowIndex = rowIndex;\n    this.childFields = data.type.children;\n    this.numChildren = this.childFields.length;\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const i = this.childIndex;\n    if (i < this.numChildren) {\n      this.childIndex = i + 1;\n      return {\n        done: false,\n        value: [this.childFields[i].name, getVisitor.visit(this.children[i], this.rowIndex)]\n      };\n    }\n    return {\n      done: true,\n      value: null\n    };\n  }\n}\nObject.defineProperties(StructRow.prototype, {\n  [Symbol.toStringTag]: {\n    enumerable: false,\n    configurable: false,\n    value: 'Row'\n  },\n  [kParent]: {\n    writable: true,\n    enumerable: false,\n    configurable: false,\n    value: null\n  },\n  [kRowIndex]: {\n    writable: true,\n    enumerable: false,\n    configurable: false,\n    value: -1\n  }\n});\nclass StructRowProxyHandler {\n  isExtensible() {\n    return false;\n  }\n  deleteProperty() {\n    return false;\n  }\n  preventExtensions() {\n    return true;\n  }\n  ownKeys(row) {\n    return row[kParent].type.children.map(f => f.name);\n  }\n  has(row, key) {\n    return row[kParent].type.children.findIndex(f => f.name === key) !== -1;\n  }\n  getOwnPropertyDescriptor(row, key) {\n    if (row[kParent].type.children.findIndex(f => f.name === key) !== -1) {\n      return {\n        writable: true,\n        enumerable: true,\n        configurable: true\n      };\n    }\n    return;\n  }\n  get(row, key) {\n    // Look up key in row first\n    if (Reflect.has(row, key)) {\n      return row[key];\n    }\n    const idx = row[kParent].type.children.findIndex(f => f.name === key);\n    if (idx !== -1) {\n      const val = getVisitor.visit(row[kParent].children[idx], row[kRowIndex]);\n      // Cache key/val lookups\n      Reflect.set(row, key, val);\n      return val;\n    }\n  }\n  set(row, key, val) {\n    const idx = row[kParent].type.children.findIndex(f => f.name === key);\n    if (idx !== -1) {\n      setVisitor.visit(row[kParent].children[idx], row[kRowIndex], val);\n      // Cache key/val lookups\n      return Reflect.set(row, key, val);\n    } else if (Reflect.has(row, key) || typeof key === 'symbol') {\n      return Reflect.set(row, key, val);\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["valueToString","instance","getVisitor","setVisitor","kParent","Symbol","for","kRowIndex","StructRow","constructor","parent","rowIndex","Proxy","StructRowProxyHandler","toArray","Object","values","toJSON","i","keys","type","children","json","j","n","length","name","visit","toString","concat","map","_ref","key","val","join","iterator","StructRowIterator","data","childIndex","childFields","numChildren","next","done","value","defineProperties","prototype","toStringTag","enumerable","configurable","writable","isExtensible","deleteProperty","preventExtensions","ownKeys","row","f","has","findIndex","getOwnPropertyDescriptor","get","Reflect","idx","set"],"sources":["C:\\Users\\emclulo\\Downloads\\GitHub\\Banco_de_Dados--Associacao_Sindrome_de_Down\\timetable_canvas\\frontend\\node_modules\\apache-arrow\\src\\row\\struct.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from '../data.js';\r\nimport { Field } from '../schema.js';\r\nimport { Struct, TypeMap } from '../type.js';\r\nimport { valueToString } from '../util/pretty.js';\r\nimport { instance as getVisitor } from '../visitor/get.js';\r\nimport { instance as setVisitor } from '../visitor/set.js';\r\n\r\n/** @ignore */ const kParent = Symbol.for('parent');\r\n/** @ignore */ const kRowIndex = Symbol.for('rowIndex');\r\n\r\nexport type StructRowProxy<T extends TypeMap = any> = StructRow<T> & {\r\n    [P in keyof T]: T[P]['TValue'];\r\n} & {\r\n    [key: symbol]: any;\r\n};\r\n\r\nexport class StructRow<T extends TypeMap = any> {\r\n\r\n    declare private [kRowIndex]: number;\r\n    declare private [kParent]: Data<Struct<T>>;\r\n\r\n    constructor(parent: Data<Struct<T>>, rowIndex: number) {\r\n        this[kParent] = parent;\r\n        this[kRowIndex] = rowIndex;\r\n        return new Proxy(this, new StructRowProxyHandler());\r\n    }\r\n\r\n    public toArray() { return Object.values(this.toJSON()); }\r\n\r\n    public toJSON() {\r\n        const i = this[kRowIndex];\r\n        const parent = this[kParent];\r\n        const keys = parent.type.children;\r\n        const json = {} as { [P in string & keyof T]: T[P]['TValue'] };\r\n        for (let j = -1, n = keys.length; ++j < n;) {\r\n            json[keys[j].name as string & keyof T] = getVisitor.visit(parent.children[j], i);\r\n        }\r\n        return json;\r\n    }\r\n\r\n    public toString() {\r\n        return `{${[...this].map(([key, val]) =>\r\n            `${valueToString(key)}: ${valueToString(val)}`\r\n        ).join(', ')\r\n            }}`;\r\n    }\r\n\r\n    public [Symbol.for('nodejs.util.inspect.custom')]() {\r\n        return this.toString();\r\n    }\r\n\r\n    [Symbol.iterator](): IterableIterator<[\r\n        keyof T, { [P in keyof T]: T[P]['TValue'] | null }[keyof T]\r\n    ]> {\r\n        return new StructRowIterator(this[kParent], this[kRowIndex]);\r\n    }\r\n}\r\n\r\nclass StructRowIterator<T extends TypeMap = any>\r\n    implements IterableIterator<[\r\n        keyof T, { [P in keyof T]: T[P]['TValue'] | null }[keyof T]\r\n    ]> {\r\n\r\n    declare private rowIndex: number;\r\n    declare private childIndex: number;\r\n    declare private numChildren: number;\r\n    declare private children: Data<any>[];\r\n    declare private childFields: Field<T[keyof T]>[];\r\n\r\n    constructor(data: Data<Struct<T>>, rowIndex: number) {\r\n        this.childIndex = 0;\r\n        this.children = data.children;\r\n        this.rowIndex = rowIndex;\r\n        this.childFields = data.type.children;\r\n        this.numChildren = this.childFields.length;\r\n    }\r\n\r\n    [Symbol.iterator]() { return this; }\r\n\r\n    next() {\r\n        const i = this.childIndex;\r\n        if (i < this.numChildren) {\r\n            this.childIndex = i + 1;\r\n            return {\r\n                done: false,\r\n                value: [\r\n                    this.childFields[i].name,\r\n                    getVisitor.visit(this.children[i], this.rowIndex)\r\n                ]\r\n            } as IteratorYieldResult<[any, any]>;\r\n        }\r\n        return { done: true, value: null } as IteratorReturnResult<null>;\r\n    }\r\n}\r\n\r\nObject.defineProperties(StructRow.prototype, {\r\n    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },\r\n    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },\r\n    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 },\r\n});\r\n\r\nclass StructRowProxyHandler<T extends TypeMap = any> implements ProxyHandler<StructRow<T>> {\r\n    isExtensible() { return false; }\r\n    deleteProperty() { return false; }\r\n    preventExtensions() { return true; }\r\n    ownKeys(row: StructRow<T>) {\r\n        return row[kParent].type.children.map((f) => f.name);\r\n    }\r\n    has(row: StructRow<T>, key: string) {\r\n        return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;\r\n    }\r\n    getOwnPropertyDescriptor(row: StructRow<T>, key: string) {\r\n        if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {\r\n            return { writable: true, enumerable: true, configurable: true };\r\n        }\r\n        return;\r\n    }\r\n    get(row: StructRow<T>, key: string) {\r\n        // Look up key in row first\r\n        if (Reflect.has(row, key)) {\r\n            return (row as any)[key];\r\n        }\r\n        const idx = row[kParent].type.children.findIndex((f) => f.name === key);\r\n        if (idx !== -1) {\r\n            const val = getVisitor.visit(row[kParent].children[idx], row[kRowIndex]);\r\n            // Cache key/val lookups\r\n            Reflect.set(row, key, val);\r\n            return val;\r\n        }\r\n    }\r\n    set(row: StructRow<T>, key: string, val: any) {\r\n        const idx = row[kParent].type.children.findIndex((f) => f.name === key);\r\n        if (idx !== -1) {\r\n            setVisitor.visit(row[kParent].children[idx], row[kRowIndex], val);\r\n            // Cache key/val lookups\r\n            return Reflect.set(row, key, val);\r\n        } else if (Reflect.has(row, key) || typeof key === 'symbol') {\r\n            return Reflect.set(row, key, val);\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}