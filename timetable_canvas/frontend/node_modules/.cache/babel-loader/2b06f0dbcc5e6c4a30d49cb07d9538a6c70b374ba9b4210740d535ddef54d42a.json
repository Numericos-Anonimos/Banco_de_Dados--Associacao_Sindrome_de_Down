{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { vectorFromArray } from './factories.mjs';\nimport { makeVector, Vector } from './vector.mjs';\nimport { Field, Schema } from './schema.mjs';\nimport { Null, Struct } from './type.mjs';\nimport { compareSchemas } from './visitor/typecomparator.mjs';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullCounts, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, sliceChunks } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\nimport { clampRange } from './util/vector.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\n/**\r\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\r\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\r\n * {@link tableFromIPC}.\r\n */\nexport class Table {\n  constructor() {\n    var _b, _c;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 0) {\n      this.batches = [];\n      this.schema = new Schema([]);\n      this._offsets = [0];\n      return this;\n    }\n    let schema;\n    let offsets;\n    if (args[0] instanceof Schema) {\n      schema = args.shift();\n    }\n    if (args[args.length - 1] instanceof Uint32Array) {\n      offsets = args.pop();\n    }\n    const unwrap = x => {\n      if (x) {\n        if (x instanceof RecordBatch) {\n          return [x];\n        } else if (x instanceof Table) {\n          return x.batches;\n        } else if (x instanceof Data) {\n          if (x.type instanceof Struct) {\n            return [new RecordBatch(new Schema(x.type.children), x)];\n          }\n        } else if (Array.isArray(x)) {\n          return x.flatMap(v => unwrap(v));\n        } else if (typeof x[Symbol.iterator] === 'function') {\n          return [...x].flatMap(v => unwrap(v));\n        } else if (typeof x === 'object') {\n          const keys = Object.keys(x);\n          const vecs = keys.map(k => new Vector([x[k]]));\n          const schema = new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type)));\n          const [, batches] = distributeVectorsIntoRecordBatches(schema, vecs);\n          return batches.length === 0 ? [new RecordBatch(x)] : batches;\n        }\n      }\n      return [];\n    };\n    const batches = args.flatMap(v => unwrap(v));\n    schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new Schema([]);\n    if (!(schema instanceof Schema)) {\n      throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n    }\n    for (const batch of batches) {\n      if (!(batch instanceof RecordBatch)) {\n        throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n      }\n      if (!compareSchemas(schema, batch.schema)) {\n        throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n      }\n    }\n    this.schema = schema;\n    this.batches = batches;\n    this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n  }\n  /**\r\n   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\r\n   */\n  get data() {\n    return this.batches.map(_ref => {\n      let {\n        data\n      } = _ref;\n      return data;\n    });\n  }\n  /**\r\n   * The number of columns in this Table.\r\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\r\n   * The number of rows in this Table.\r\n   */\n  get numRows() {\n    return this.data.reduce((numRows, data) => numRows + data.length, 0);\n  }\n  /**\r\n   * The number of null rows in this Table.\r\n   */\n  get nullCount() {\n    if (this._nullCount === -1) {\n      this._nullCount = computeChunkNullCounts(this.data);\n    }\n    return this._nullCount;\n  }\n  /**\r\n   * Check whether an element is null.\r\n   *\r\n   * @param index The index at which to read the validity bitmap.\r\n   */\n  // @ts-ignore\n  isValid(index) {\n    return false;\n  }\n  /**\r\n   * Get an element value by position.\r\n   *\r\n   * @param index The index of the element to read.\r\n   */\n  // @ts-ignore\n  get(index) {\n    return null;\n  }\n  /**\r\n   * Set an element value by position.\r\n   *\r\n   * @param index The index of the element to write.\r\n   * @param value The value to set.\r\n   */\n  // @ts-ignore\n  set(index, value) {\n    return;\n  }\n  /**\r\n   * Retrieve the index of the first occurrence of a value in an Vector.\r\n   *\r\n   * @param element The value to locate in the Vector.\r\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\r\n   */\n  // @ts-ignore\n  indexOf(element, offset) {\n    return -1;\n  }\n  /**\r\n   * Get the size in bytes of an element by index.\r\n   * @param index The index at which to get the byteLength.\r\n   */\n  // @ts-ignore\n  getByteLength(index) {\n    return 0;\n  }\n  /**\r\n   * Iterator for rows in this Table.\r\n   */\n  [Symbol.iterator]() {\n    if (this.batches.length > 0) {\n      return iteratorVisitor.visit(new Vector(this.data));\n    }\n    return new Array(0)[Symbol.iterator]();\n  }\n  /**\r\n   * Return a JavaScript Array of the Table rows.\r\n   *\r\n   * @returns An Array of Table rows.\r\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\r\n   * Returns a string representation of the Table rows.\r\n   *\r\n   * @returns A string representation of the Table rows.\r\n   */\n  toString() {\n    return \"[\\n  \".concat(this.toArray().join(',\\n  '), \"\\n]\");\n  }\n  /**\r\n   * Combines two or more Tables of the same schema.\r\n   *\r\n   * @param others Additional Tables to add to the end of this Tables.\r\n   */\n  concat() {\n    const schema = this.schema;\n    for (var _len2 = arguments.length, others = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      others[_key2] = arguments[_key2];\n    }\n    const data = this.data.concat(others.flatMap(_ref2 => {\n      let {\n        data\n      } = _ref2;\n      return data;\n    }));\n    return new Table(schema, data.map(data => new RecordBatch(schema, data)));\n  }\n  /**\r\n   * Return a zero-copy sub-section of this Table.\r\n   *\r\n   * @param begin The beginning of the specified portion of the Table.\r\n   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\r\n   */\n  slice(begin, end) {\n    const schema = this.schema;\n    [begin, end] = clampRange({\n      length: this.numRows\n    }, begin, end);\n    const data = sliceChunks(this.data, this._offsets, begin, end);\n    return new Table(schema, data.map(chunk => new RecordBatch(schema, chunk)));\n  }\n  /**\r\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\r\n   *\r\n   * @param name The name of the child to retrieve.\r\n   */\n  getChild(name) {\n    return this.getChildAt(this.schema.fields.findIndex(f => f.name === name));\n  }\n  /**\r\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\r\n   *\r\n   * @param index The index of the child to retrieve.\r\n   */\n  getChildAt(index) {\n    if (index > -1 && index < this.schema.fields.length) {\n      const data = this.data.map(data => data.children[index]);\n      if (data.length === 0) {\n        const {\n          type\n        } = this.schema.fields[index];\n        const empty = makeData({\n          type,\n          length: 0,\n          nullCount: 0\n        });\n        data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n      }\n      return new Vector(data);\n    }\n    return null;\n  }\n  /**\r\n   * Sets a child Vector by name.\r\n   *\r\n   * @param name The name of the child to overwrite.\r\n   * @returns A new Table with the supplied child for the specified name.\r\n   */\n  setChild(name, child) {\n    var _b;\n    return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name), child);\n  }\n  setChildAt(index, child) {\n    let schema = this.schema;\n    let batches = [...this.batches];\n    if (index > -1 && index < this.numCols) {\n      if (!child) {\n        child = new Vector([makeData({\n          type: new Null(),\n          length: this.numRows\n        })]);\n      }\n      const fields = schema.fields.slice();\n      const field = fields[index].clone({\n        type: child.type\n      });\n      const children = this.schema.fields.map((_, i) => this.getChildAt(i));\n      [fields[index], children[index]] = [field, child];\n      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n    }\n    return new Table(schema, batches);\n  }\n  /**\r\n   * Construct a new Table containing only specified columns.\r\n   *\r\n   * @param columnNames Names of columns to keep.\r\n   * @returns A new Table of columns matching the specified names.\r\n   */\n  select(columnNames) {\n    const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n    return this.selectAt(columnNames.map(columnName => nameToIndex.get(columnName)).filter(x => x > -1));\n  }\n  /**\r\n   * Construct a new Table containing only columns at the specified indices.\r\n   *\r\n   * @param columnIndices Indices of columns to keep.\r\n   * @returns A new Table of columns at the specified indices.\r\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const data = this.batches.map(batch => batch.selectAt(columnIndices));\n    return new Table(schema, data);\n  }\n  assign(other) {\n    const fields = this.schema.fields;\n    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n      const [indices, oldToNew] = memo;\n      const i = fields.findIndex(f => f.name === f2.name);\n      ~i ? oldToNew[i] = newIdx : indices.push(newIdx);\n      return memo;\n    }, [[], []]);\n    const schema = this.schema.assign(other.schema);\n    const columns = [...fields.map((_, i) => [i, oldToNew[i]]).map(_ref3 => {\n      let [i, j] = _ref3;\n      return j === undefined ? this.getChildAt(i) : other.getChildAt(j);\n    }), ...indices.map(i => other.getChildAt(i))].filter(Boolean);\n    return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n  }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nTable[_a] = (proto => {\n  proto.schema = null;\n  proto.batches = [];\n  proto._offsets = new Uint32Array([0]);\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  proto['isValid'] = wrapChunkedCall1(isChunkedValid);\n  proto['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n  proto['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n  proto['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n  proto['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\n  return 'Table';\n})(Table.prototype);\n/**\r\n * Creates a new Table from an object of typed arrays.\r\n *\r\n*  @example\r\n * ```ts\r\n * const table = makeTable({\r\n *   a: new Int8Array([1, 2, 3]),\r\n * })\r\n * ```\r\n *\r\n * @param input Input an object of typed arrays.\r\n * @returns A new Table.\r\n */\nexport function makeTable(input) {\n  const vecs = {};\n  const inputs = Object.entries(input);\n  for (const [key, col] of inputs) {\n    vecs[key] = makeVector(col);\n  }\n  return new Table(vecs);\n}\n/**\r\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\r\n *\r\n *  @example\r\n * ```ts\r\n * const table = tableFromArrays({\r\n *   a: [1, 2, 3],\r\n *   b: new Int8Array([1, 2, 3]),\r\n * })\r\n * ```\r\n *\r\n * @param input Input an object of typed arrays or JavaScript arrays.\r\n * @returns A new Table.\r\n */\nexport function tableFromArrays(input) {\n  const vecs = {};\n  const inputs = Object.entries(input);\n  for (const [key, col] of inputs) {\n    vecs[key] = vectorFromArray(col);\n  }\n  return new Table(vecs);\n}","map":{"version":3,"names":["Type","Data","makeData","vectorFromArray","makeVector","Vector","Field","Schema","Null","Struct","compareSchemas","distributeVectorsIntoRecordBatches","isChunkedValid","computeChunkOffsets","computeChunkNullCounts","wrapChunkedCall1","wrapChunkedCall2","wrapChunkedIndexOf","sliceChunks","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","clampRange","RecordBatch","Table","constructor","args","Array","_len","_key","arguments","length","batches","schema","_offsets","offsets","shift","Uint32Array","pop","unwrap","x","type","children","isArray","flatMap","v","Symbol","iterator","keys","Object","vecs","map","k","i","String","_c","_b","TypeError","batch","data","_ref","numCols","fields","numRows","reduce","nullCount","_nullCount","isValid","index","get","set","value","indexOf","element","offset","getByteLength","visit","toArray","toString","concat","join","_len2","others","_key2","_ref2","slice","begin","end","chunk","getChild","name","getChildAt","findIndex","f","empty","push","_changeLengthAndBackfillNullBitmap","setChild","child","setChildAt","field","clone","_","select","columnNames","nameToIndex","m","Map","selectAt","columnName","filter","columnIndices","assign","other","indices","oldToNew","memo","f2","newIdx","columns","_ref3","j","undefined","Boolean","toStringTag","_a","proto","isConcatSpreadable","getVisitFn","prototype","makeTable","input","inputs","entries","key","col","tableFromArrays"],"sources":["C:\\Users\\emclulo\\Downloads\\GitHub\\Banco_de_Dados--Associacao_Sindrome_de_Down\\timetable_canvas\\frontend\\node_modules\\apache-arrow\\src\\table.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Type } from './enum.js';\r\nimport { Data, makeData } from './data.js';\r\nimport { vectorFromArray } from './factories.js';\r\nimport { makeVector, Vector } from './vector.js';\r\nimport { Field, Schema } from './schema.js';\r\nimport { DataType, Null, Struct, TypeMap } from './type.js';\r\nimport { compareSchemas } from './visitor/typecomparator.js';\r\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.js';\r\n\r\nimport {\r\n    isChunkedValid,\r\n    computeChunkOffsets,\r\n    computeChunkNullCounts,\r\n    wrapChunkedCall1,\r\n    wrapChunkedCall2,\r\n    wrapChunkedIndexOf,\r\n    sliceChunks,\r\n} from './util/chunk.js';\r\n\r\nimport { instance as getVisitor } from './visitor/get.js';\r\nimport { instance as setVisitor } from './visitor/set.js';\r\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\r\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\r\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\r\n\r\nimport { DataProps } from './data.js';\r\nimport { clampRange } from './util/vector.js';\r\nimport { ArrayDataType, BigIntArray, TypedArray, TypedArrayDataType } from './interfaces.js';\r\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from './recordbatch.js';\r\n\r\n/** @ignore */\r\nexport interface Table<T extends TypeMap = any> {\r\n    ///\r\n    // Virtual properties for the TypeScript compiler.\r\n    // These do not exist at runtime.\r\n    ///\r\n    readonly TType: Struct<T>;\r\n    readonly TArray: Struct<T>['TArray'];\r\n    readonly TValue: Struct<T>['TValue'];\r\n\r\n    /**\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\r\n     */\r\n    [Symbol.isConcatSpreadable]: true;\r\n}\r\n\r\n/**\r\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\r\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\r\n * {@link tableFromIPC}.\r\n */\r\nexport class Table<T extends TypeMap = any> {\r\n\r\n    constructor();\r\n    constructor(batches: Iterable<RecordBatch<T>>);\r\n    constructor(...batches: readonly RecordBatch<T>[]);\r\n    constructor(...columns: { [P in keyof T]: Vector<T[P]> }[]);\r\n    constructor(...columns: { [P in keyof T]: Data<T[P]> | DataProps<T[P]> }[]);\r\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[]);\r\n    constructor(schema: Schema<T>, data?: RecordBatch<T> | RecordBatch<T>[], offsets?: Uint32Array);\r\n    constructor(...args: any[]) {\r\n\r\n        if (args.length === 0) {\r\n            this.batches = [];\r\n            this.schema = new Schema([]);\r\n            this._offsets = [0];\r\n            return this;\r\n        }\r\n\r\n        let schema: Schema<T> | undefined;\r\n        let offsets: Uint32Array | number[] | undefined;\r\n\r\n        if (args[0] instanceof Schema) {\r\n            schema = args.shift() as Schema<T>;\r\n        }\r\n\r\n        if (args[args.length - 1] instanceof Uint32Array) {\r\n            offsets = args.pop();\r\n        }\r\n\r\n        const unwrap = (x: any): RecordBatch<T>[] => {\r\n            if (x) {\r\n                if (x instanceof RecordBatch) {\r\n                    return [x];\r\n                } else if (x instanceof Table) {\r\n                    return x.batches;\r\n                } else if (x instanceof Data) {\r\n                    if (x.type instanceof Struct) {\r\n                        return [new RecordBatch(new Schema(x.type.children), x)];\r\n                    }\r\n                } else if (Array.isArray(x)) {\r\n                    return x.flatMap(v => unwrap(v));\r\n                } else if (typeof x[Symbol.iterator] === 'function') {\r\n                    return [...x].flatMap(v => unwrap(v));\r\n                } else if (typeof x === 'object') {\r\n                    const keys = Object.keys(x) as (keyof T)[];\r\n                    const vecs = keys.map((k) => new Vector([x[k]]));\r\n                    const schema = new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type)));\r\n                    const [, batches] = distributeVectorsIntoRecordBatches(schema, vecs);\r\n                    return batches.length === 0 ? [new RecordBatch(x)] : batches;\r\n                }\r\n            }\r\n            return [];\r\n        };\r\n\r\n        const batches = args.flatMap(v => unwrap(v));\r\n\r\n        schema = schema ?? batches[0]?.schema ?? new Schema([]);\r\n\r\n        if (!(schema instanceof Schema)) {\r\n            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\r\n        }\r\n\r\n        for (const batch of batches) {\r\n            if (!(batch instanceof RecordBatch)) {\r\n                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\r\n            }\r\n            if (!compareSchemas(schema, batch.schema)) {\r\n                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\r\n            }\r\n        }\r\n\r\n        this.schema = schema;\r\n        this.batches = batches;\r\n        this._offsets = offsets ?? computeChunkOffsets(this.data);\r\n    }\r\n\r\n    declare protected _offsets: Uint32Array | number[];\r\n    declare protected _nullCount: number;\r\n\r\n    declare public readonly schema: Schema<T>;\r\n\r\n    /**\r\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\r\n     */\r\n    declare public readonly batches: RecordBatch<T>[];\r\n\r\n    /**\r\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\r\n     */\r\n    public get data() { return this.batches.map(({ data }) => data); }\r\n\r\n    /**\r\n     * The number of columns in this Table.\r\n     */\r\n    public get numCols() { return this.schema.fields.length; }\r\n\r\n    /**\r\n     * The number of rows in this Table.\r\n     */\r\n    public get numRows() {\r\n        return this.data.reduce((numRows, data) => numRows + data.length, 0);\r\n    }\r\n\r\n    /**\r\n     * The number of null rows in this Table.\r\n     */\r\n    public get nullCount() {\r\n        if (this._nullCount === -1) {\r\n            this._nullCount = computeChunkNullCounts(this.data);\r\n        }\r\n        return this._nullCount;\r\n    }\r\n\r\n    /**\r\n     * Check whether an element is null.\r\n     *\r\n     * @param index The index at which to read the validity bitmap.\r\n     */\r\n    // @ts-ignore\r\n    public isValid(index: number): boolean { return false; }\r\n\r\n    /**\r\n     * Get an element value by position.\r\n     *\r\n     * @param index The index of the element to read.\r\n     */\r\n    // @ts-ignore\r\n    public get(index: number): Struct<T>['TValue'] | null { return null; }\r\n\r\n    /**\r\n     * Set an element value by position.\r\n     *\r\n     * @param index The index of the element to write.\r\n     * @param value The value to set.\r\n     */\r\n    // @ts-ignore\r\n    public set(index: number, value: Struct<T>['TValue'] | null): void { return; }\r\n\r\n    /**\r\n     * Retrieve the index of the first occurrence of a value in an Vector.\r\n     *\r\n     * @param element The value to locate in the Vector.\r\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\r\n     */\r\n    // @ts-ignore\r\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number { return -1; }\r\n\r\n    /**\r\n     * Get the size in bytes of an element by index.\r\n     * @param index The index at which to get the byteLength.\r\n     */\r\n    // @ts-ignore\r\n    public getByteLength(index: number): number { return 0; }\r\n\r\n    /**\r\n     * Iterator for rows in this Table.\r\n     */\r\n    public [Symbol.iterator]() {\r\n        if (this.batches.length > 0) {\r\n            return iteratorVisitor.visit(new Vector(this.data)) as IterableIterator<Struct<T>['TValue']>;\r\n        }\r\n        return (new Array(0))[Symbol.iterator]();\r\n    }\r\n\r\n    /**\r\n     * Return a JavaScript Array of the Table rows.\r\n     *\r\n     * @returns An Array of Table rows.\r\n     */\r\n    public toArray() {\r\n        return [...this];\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the Table rows.\r\n     *\r\n     * @returns A string representation of the Table rows.\r\n     */\r\n    public toString() {\r\n        return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\r\n    }\r\n\r\n    /**\r\n     * Combines two or more Tables of the same schema.\r\n     *\r\n     * @param others Additional Tables to add to the end of this Tables.\r\n     */\r\n    public concat(...others: Table<T>[]) {\r\n        const schema = this.schema;\r\n        const data = this.data.concat(others.flatMap(({ data }) => data));\r\n        return new Table(schema, data.map((data) => new RecordBatch(schema, data)));\r\n    }\r\n\r\n    /**\r\n     * Return a zero-copy sub-section of this Table.\r\n     *\r\n     * @param begin The beginning of the specified portion of the Table.\r\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\r\n     */\r\n    public slice(begin?: number, end?: number): Table<T> {\r\n        const schema = this.schema;\r\n        [begin, end] = clampRange({ length: this.numRows }, begin, end);\r\n        const data = sliceChunks(this.data, this._offsets, begin, end);\r\n        return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\r\n    }\r\n\r\n    /**\r\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\r\n     *\r\n     * @param name The name of the child to retrieve.\r\n     */\r\n    public getChild<P extends keyof T>(name: P) {\r\n        return this.getChildAt<T[P]>(this.schema.fields.findIndex((f) => f.name === name));\r\n    }\r\n\r\n    /**\r\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\r\n     *\r\n     * @param index The index of the child to retrieve.\r\n     */\r\n    public getChildAt<R extends T[keyof T] = any>(index: number): Vector<R> | null {\r\n        if (index > -1 && index < this.schema.fields.length) {\r\n            const data = this.data.map((data) => data.children[index] as Data<R>);\r\n            if (data.length === 0) {\r\n                const { type } = this.schema.fields[index] as Field<R>;\r\n                const empty = makeData<R>({ type, length: 0, nullCount: 0 });\r\n                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\r\n            }\r\n            return new Vector(data);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets a child Vector by name.\r\n     *\r\n     * @param name The name of the child to overwrite.\r\n     * @returns A new Table with the supplied child for the specified name.\r\n     */\r\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\r\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as Table<T & { [K in P]: R }>;\r\n    }\r\n\r\n    /**\r\n     * Sets a child Vector by index.\r\n     *\r\n     * @param index The index of the child to overwrite.\r\n     * @returns A new Table with the supplied child at the specified index.\r\n     */\r\n    public setChildAt(index: number, child?: null): Table;\r\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): Table;\r\n    public setChildAt(index: number, child: any) {\r\n        let schema: Schema = this.schema;\r\n        let batches: RecordBatch[] = [...this.batches];\r\n        if (index > -1 && index < this.numCols) {\r\n            if (!child) {\r\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\r\n            }\r\n            const fields = schema.fields.slice() as Field<any>[];\r\n            const field = fields[index].clone({ type: child.type });\r\n            const children = this.schema.fields.map((_, i) => this.getChildAt(i)!);\r\n            [fields[index], children[index]] = [field, child];\r\n            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\r\n        }\r\n        return new Table(schema, batches);\r\n    }\r\n\r\n    /**\r\n     * Construct a new Table containing only specified columns.\r\n     *\r\n     * @param columnNames Names of columns to keep.\r\n     * @returns A new Table of columns matching the specified names.\r\n     */\r\n    public select<K extends keyof T = any>(columnNames: K[]) {\r\n        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\r\n        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\r\n    }\r\n\r\n    /**\r\n     * Construct a new Table containing only columns at the specified indices.\r\n     *\r\n     * @param columnIndices Indices of columns to keep.\r\n     * @returns A new Table of columns at the specified indices.\r\n     */\r\n    public selectAt<K extends T[keyof T] = any>(columnIndices: number[]) {\r\n        const schema = this.schema.selectAt(columnIndices);\r\n        const data = this.batches.map((batch) => batch.selectAt(columnIndices));\r\n        return new Table<{ [key: string]: K }>(schema, data);\r\n    }\r\n\r\n    public assign<R extends TypeMap = any>(other: Table<R>) {\r\n\r\n        const fields = this.schema.fields;\r\n        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\r\n            const [indices, oldToNew] = memo;\r\n            const i = fields.findIndex((f) => f.name === f2.name);\r\n            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);\r\n            return memo;\r\n        }, [[], []] as number[][]);\r\n\r\n        const schema = this.schema.assign(other.schema);\r\n        const columns = [\r\n            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) =>\r\n                (j === undefined ? this.getChildAt(i) : other.getChildAt(j))!),\r\n            ...indices.map((i) => other.getChildAt(i)!)\r\n        ].filter(Boolean) as Vector<(T & R)[keyof T | keyof R]>[];\r\n\r\n        return new Table<T & R>(...distributeVectorsIntoRecordBatches<any>(schema, columns));\r\n    }\r\n\r\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\r\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\r\n    protected static [Symbol.toStringTag] = ((proto: Table) => {\r\n        (proto as any).schema = null;\r\n        (proto as any).batches = [];\r\n        (proto as any)._offsets = new Uint32Array([0]);\r\n        (proto as any)._nullCount = -1;\r\n        (proto as any)[Symbol.isConcatSpreadable] = true;\r\n        (proto as any)['isValid'] = wrapChunkedCall1(isChunkedValid);\r\n        (proto as any)['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\r\n        (proto as any)['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\r\n        (proto as any)['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\r\n        (proto as any)['getByteLength'] = wrapChunkedCall1(byteLengthVisitor.getVisitFn(Type.Struct));\r\n        return 'Table';\r\n    })(Table.prototype);\r\n}\r\n\r\n\r\ntype VectorsMap<T extends TypeMap> = { [P in keyof T]: Vector<T[P]> };\r\n\r\n/**\r\n * Creates a new Table from an object of typed arrays.\r\n *\r\n*  @example\r\n * ```ts\r\n * const table = makeTable({\r\n *   a: new Int8Array([1, 2, 3]),\r\n * })\r\n * ```\r\n *\r\n * @param input Input an object of typed arrays.\r\n * @returns A new Table.\r\n */\r\nexport function makeTable<I extends Record<string | number | symbol, TypedArray>>(input: I): Table<{ [P in keyof I]: TypedArrayDataType<I[P]> }> {\r\n    type T = { [P in keyof I]: TypedArrayDataType<I[P]> };\r\n    const vecs = {} as VectorsMap<T>;\r\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\r\n    for (const [key, col] of inputs) {\r\n        vecs[key] = makeVector(col);\r\n    }\r\n    return new Table<T>(vecs);\r\n}\r\n\r\n/**\r\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\r\n *\r\n *  @example\r\n * ```ts\r\n * const table = tableFromArrays({\r\n *   a: [1, 2, 3],\r\n *   b: new Int8Array([1, 2, 3]),\r\n * })\r\n * ```\r\n *\r\n * @param input Input an object of typed arrays or JavaScript arrays.\r\n * @returns A new Table.\r\n */\r\nexport function tableFromArrays<I extends Record<string | number | symbol, TypedArray | BigIntArray | readonly unknown[]>>(input: I): Table<{ [P in keyof I]: ArrayDataType<I[P]> }> {\r\n    type T = { [P in keyof I]: ArrayDataType<I[P]> };\r\n    const vecs = {} as VectorsMap<T>;\r\n    const inputs = Object.entries(input) as [keyof I, I[keyof I]][];\r\n    for (const [key, col] of inputs) {\r\n        vecs[key] = vectorFromArray(col);\r\n    }\r\n    return new Table<T>(vecs);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}