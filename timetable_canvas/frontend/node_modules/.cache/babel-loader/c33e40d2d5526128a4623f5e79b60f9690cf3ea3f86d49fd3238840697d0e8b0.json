{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport { DictionaryBatch } from './dictionary-batch.mjs';\nimport { RecordBatch } from './record-batch.mjs';\nimport { Schema } from './schema.mjs';\nimport { SparseTensor } from './sparse-tensor.mjs';\nimport { Tensor } from './tensor.mjs';\n/**\r\n * ----------------------------------------------------------------------\r\n * The root Message type\r\n * This union enables us to easily send different message types without\r\n * redundant storage, and in the future we can easily add new message types.\r\n *\r\n * Arrow implementations do not need to implement all of the message types,\r\n * which may include experimental metadata types. For maximum compatibility,\r\n * it is best to send data using RecordBatch\r\n */\nexport var MessageHeader;\n(function (MessageHeader) {\n  MessageHeader[MessageHeader[\"NONE\"] = 0] = \"NONE\";\n  MessageHeader[MessageHeader[\"Schema\"] = 1] = \"Schema\";\n  MessageHeader[MessageHeader[\"DictionaryBatch\"] = 2] = \"DictionaryBatch\";\n  MessageHeader[MessageHeader[\"RecordBatch\"] = 3] = \"RecordBatch\";\n  MessageHeader[MessageHeader[\"Tensor\"] = 4] = \"Tensor\";\n  MessageHeader[MessageHeader[\"SparseTensor\"] = 5] = \"SparseTensor\";\n})(MessageHeader || (MessageHeader = {}));\nexport function unionToMessageHeader(type, accessor) {\n  switch (MessageHeader[type]) {\n    case 'NONE':\n      return null;\n    case 'Schema':\n      return accessor(new Schema());\n    case 'DictionaryBatch':\n      return accessor(new DictionaryBatch());\n    case 'RecordBatch':\n      return accessor(new RecordBatch());\n    case 'Tensor':\n      return accessor(new Tensor());\n    case 'SparseTensor':\n      return accessor(new SparseTensor());\n    default:\n      return null;\n  }\n}\nexport function unionListToMessageHeader(type, accessor, index) {\n  switch (MessageHeader[type]) {\n    case 'NONE':\n      return null;\n    case 'Schema':\n      return accessor(index, new Schema());\n    case 'DictionaryBatch':\n      return accessor(index, new DictionaryBatch());\n    case 'RecordBatch':\n      return accessor(index, new RecordBatch());\n    case 'Tensor':\n      return accessor(index, new Tensor());\n    case 'SparseTensor':\n      return accessor(index, new SparseTensor());\n    default:\n      return null;\n  }\n}","map":{"version":3,"names":["DictionaryBatch","RecordBatch","Schema","SparseTensor","Tensor","MessageHeader","unionToMessageHeader","type","accessor","unionListToMessageHeader","index"],"sources":["C:\\Users\\emclulo\\Downloads\\GitHub\\Banco_de_Dados--Associacao_Sindrome_de_Down\\timetable_canvas\\frontend\\node_modules\\apache-arrow\\src\\fb\\message-header.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\r\n\r\nimport { DictionaryBatch } from './dictionary-batch.js';\r\nimport { RecordBatch } from './record-batch.js';\r\nimport { Schema } from './schema.js';\r\nimport { SparseTensor } from './sparse-tensor.js';\r\nimport { Tensor } from './tensor.js';\r\n\r\n\r\n/**\r\n * ----------------------------------------------------------------------\r\n * The root Message type\r\n * This union enables us to easily send different message types without\r\n * redundant storage, and in the future we can easily add new message types.\r\n *\r\n * Arrow implementations do not need to implement all of the message types,\r\n * which may include experimental metadata types. For maximum compatibility,\r\n * it is best to send data using RecordBatch\r\n */\r\nexport enum MessageHeader{\r\n  NONE = 0,\r\n  Schema = 1,\r\n  DictionaryBatch = 2,\r\n  RecordBatch = 3,\r\n  Tensor = 4,\r\n  SparseTensor = 5\r\n}\r\n\r\nexport function unionToMessageHeader(\r\n  type: MessageHeader,\r\n  accessor: (obj:DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor) => DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null\r\n): DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null {\r\n  switch(MessageHeader[type]) {\r\n    case 'NONE': return null;\r\n    case 'Schema': return accessor(new Schema())! as Schema;\r\n    case 'DictionaryBatch': return accessor(new DictionaryBatch())! as DictionaryBatch;\r\n    case 'RecordBatch': return accessor(new RecordBatch())! as RecordBatch;\r\n    case 'Tensor': return accessor(new Tensor())! as Tensor;\r\n    case 'SparseTensor': return accessor(new SparseTensor())! as SparseTensor;\r\n    default: return null;\r\n  }\r\n}\r\n\r\nexport function unionListToMessageHeader(\r\n  type: MessageHeader,\r\n  accessor: (index: number, obj:DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor) => DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null,\r\n  index: number\r\n): DictionaryBatch|RecordBatch|Schema|SparseTensor|Tensor|null {\r\n  switch(MessageHeader[type]) {\r\n    case 'NONE': return null;\r\n    case 'Schema': return accessor(index, new Schema())! as Schema;\r\n    case 'DictionaryBatch': return accessor(index, new DictionaryBatch())! as DictionaryBatch;\r\n    case 'RecordBatch': return accessor(index, new RecordBatch())! as RecordBatch;\r\n    case 'Tensor': return accessor(index, new Tensor())! as Tensor;\r\n    case 'SparseTensor': return accessor(index, new SparseTensor())! as SparseTensor;\r\n    default: return null;\r\n  }\r\n}\r\n\r\n"],"mappings":"AAAA;AAEA,SAASA,eAAe,QAAQ,wBAAwB;AACxD,SAASC,WAAW,QAAQ,oBAAoB;AAChD,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,YAAY,QAAQ,qBAAqB;AAClD,SAASC,MAAM,QAAQ,cAAc;AAGrC;;;;;;;;;;AAUA,WAAYC,aAOX;AAPD,WAAYA,aAAa;EACvBA,aAAA,CAAAA,aAAA,sBAAQ;EACRA,aAAA,CAAAA,aAAA,0BAAU;EACVA,aAAA,CAAAA,aAAA,4CAAmB;EACnBA,aAAA,CAAAA,aAAA,oCAAe;EACfA,aAAA,CAAAA,aAAA,0BAAU;EACVA,aAAA,CAAAA,aAAA,sCAAgB;AAClB,CAAC,EAPWA,aAAa,KAAbA,aAAa;AASzB,OAAM,SAAUC,oBAAoBA,CAClCC,IAAmB,EACnBC,QAAqI;EAErI,QAAOH,aAAa,CAACE,IAAI,CAAC;IACxB,KAAK,MAAM;MAAE,OAAO,IAAI;IACxB,KAAK,QAAQ;MAAE,OAAOC,QAAQ,CAAC,IAAIN,MAAM,EAAE,CAAY;IACvD,KAAK,iBAAiB;MAAE,OAAOM,QAAQ,CAAC,IAAIR,eAAe,EAAE,CAAqB;IAClF,KAAK,aAAa;MAAE,OAAOQ,QAAQ,CAAC,IAAIP,WAAW,EAAE,CAAiB;IACtE,KAAK,QAAQ;MAAE,OAAOO,QAAQ,CAAC,IAAIJ,MAAM,EAAE,CAAY;IACvD,KAAK,cAAc;MAAE,OAAOI,QAAQ,CAAC,IAAIL,YAAY,EAAE,CAAkB;IACzE;MAAS,OAAO,IAAI;;AAExB;AAEA,OAAM,SAAUM,wBAAwBA,CACtCF,IAAmB,EACnBC,QAAoJ,EACpJE,KAAa;EAEb,QAAOL,aAAa,CAACE,IAAI,CAAC;IACxB,KAAK,MAAM;MAAE,OAAO,IAAI;IACxB,KAAK,QAAQ;MAAE,OAAOC,QAAQ,CAACE,KAAK,EAAE,IAAIR,MAAM,EAAE,CAAY;IAC9D,KAAK,iBAAiB;MAAE,OAAOM,QAAQ,CAACE,KAAK,EAAE,IAAIV,eAAe,EAAE,CAAqB;IACzF,KAAK,aAAa;MAAE,OAAOQ,QAAQ,CAACE,KAAK,EAAE,IAAIT,WAAW,EAAE,CAAiB;IAC7E,KAAK,QAAQ;MAAE,OAAOO,QAAQ,CAACE,KAAK,EAAE,IAAIN,MAAM,EAAE,CAAY;IAC9D,KAAK,cAAc;MAAE,OAAOI,QAAQ,CAACE,KAAK,EAAE,IAAIP,YAAY,EAAE,CAAkB;IAChF;MAAS,OAAO,IAAI;;AAExB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}