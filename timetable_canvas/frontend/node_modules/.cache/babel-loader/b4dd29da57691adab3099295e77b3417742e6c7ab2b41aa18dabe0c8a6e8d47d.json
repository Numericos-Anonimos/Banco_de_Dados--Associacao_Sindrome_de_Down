{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { UnionMode } from '../enum.mjs';\nimport { RecordBatch } from '../recordbatch.mjs';\nimport { rebaseValueOffsets } from '../util/buffer.mjs';\nimport { packBools, truncateBitmap } from '../util/bit.mjs';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.mjs';\nimport { DataType } from '../type.mjs';\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n  constructor() {\n    super();\n    this._byteLength = 0;\n    this._nodes = [];\n    this._buffers = [];\n    this._bufferRegions = [];\n  }\n  /** @nocollapse */\n  static assemble() {\n    const unwrap = nodes => nodes.flatMap(node => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);\n    const assembler = new VectorAssembler();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    assembler.visitMany(unwrap(args));\n    return assembler;\n  }\n  visit(data) {\n    if (data instanceof Vector) {\n      this.visitMany(data.data);\n      return this;\n    }\n    const {\n      type\n    } = data;\n    if (!DataType.isDictionary(type)) {\n      const {\n        length,\n        nullCount\n      } = data;\n      if (length > 2147483647) {\n        /* istanbul ignore next */\n        throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n      }\n      if (!DataType.isNull(type)) {\n        addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) // placeholder validity buffer\n        : truncateBitmap(data.offset, length, data.nullBitmap));\n      }\n      this.nodes.push(new FieldNode(length, nullCount));\n    }\n    return super.visit(data);\n  }\n  visitNull(_null) {\n    return this;\n  }\n  visitDictionary(data) {\n    // Assemble the indices here, Dictionary assembled separately.\n    return this.visit(data.clone(data.type.indices));\n  }\n  get nodes() {\n    return this._nodes;\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get bufferRegions() {\n    return this._bufferRegions;\n  }\n}\n/** @ignore */\nfunction addBuffer(values) {\n  const byteLength = values.byteLength + 7 & ~7; // Round up to a multiple of 8\n  this.buffers.push(values);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\n/** @ignore */\nfunction assembleUnion(data) {\n  const {\n    type,\n    length,\n    typeIds,\n    valueOffsets\n  } = data;\n  // All Union Vectors have a typeIds buffer\n  addBuffer.call(this, typeIds);\n  // If this is a Sparse Union, treat it like all other Nested types\n  if (type.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, data);\n  } else if (type.mode === UnionMode.Dense) {\n    // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n    if (data.offset <= 0) {\n      // If the Vector hasn't been sliced, write the existing valueOffsets\n      addBuffer.call(this, valueOffsets);\n      // We can treat this like all other Nested types\n      return assembleNestedVector.call(this, data);\n    } else {\n      // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n      // each child vector, we need to \"rebase\" the valueOffsets for each child\n      // Union typeIds are not necessary 0-indexed\n      const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\n      const childLengths = new Int32Array(maxChildTypeId + 1);\n      // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n      const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      const shiftedOffsets = new Int32Array(length);\n      // If we have a non-zero offset, then the value offsets do not start at\n      // zero. We must a) create a new offsets array with shifted offsets and\n      // b) slice the values array accordingly\n      const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n      for (let typeId, shift, index = -1; ++index < length;) {\n        if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n        shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n        ++childLengths[typeId];\n      }\n      addBuffer.call(this, shiftedOffsets);\n      // Slice and visit children accordingly\n      for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n        if (child = data.children[childIndex]) {\n          const typeId = type.typeIds[childIndex];\n          const childLength = Math.min(length, childLengths[typeId]);\n          this.visit(child.slice(childOffsets[typeId], childLength));\n        }\n      }\n    }\n  }\n  return this;\n}\n/** @ignore */\nfunction assembleBoolVector(data) {\n  // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n  let values;\n  if (data.nullCount >= data.length) {\n    // If all values are null, just insert a placeholder empty data buffer (fastest path)\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values = data.values) instanceof Uint8Array) {\n    // If values is already a Uint8Array, slice the bitmap (fast path)\n    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\n  }\n  // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n  // values as bools and re-pack them into a Uint8Array. This code isn't\n  // reachable unless you're trying to manipulate the Data internals,\n  // we're only doing this for safety.\n  /* istanbul ignore next */\n  return addBuffer.call(this, packBools(data.values));\n}\n/** @ignore */\nfunction assembleFlatVector(data) {\n  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\n/** @ignore */\nfunction assembleFlatListVector(data) {\n  const {\n    length,\n    values,\n    valueOffsets\n  } = data;\n  const firstOffset = valueOffsets[0];\n  const lastOffset = valueOffsets[length];\n  const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n  // Push in the order FlatList types read their buffers\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n  addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n  return this;\n}\n/** @ignore */\nfunction assembleListVector(data) {\n  const {\n    length,\n    valueOffsets\n  } = data;\n  // If we have valueOffsets (MapVector, ListVector), push that buffer first\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n  }\n  // Then insert the List's values child\n  return this.visit(data.children[0]);\n}\n/** @ignore */\nfunction assembleNestedVector(data) {\n  return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;","map":{"version":3,"names":["Vector","Visitor","UnionMode","RecordBatch","rebaseValueOffsets","packBools","truncateBitmap","BufferRegion","FieldNode","DataType","VectorAssembler","constructor","_byteLength","_nodes","_buffers","_bufferRegions","assemble","unwrap","nodes","flatMap","node","Array","isArray","data","children","assembler","_len","arguments","length","args","_key","visitMany","visit","type","isDictionary","nullCount","RangeError","isNull","addBuffer","call","Uint8Array","offset","nullBitmap","push","visitNull","_null","visitDictionary","clone","indices","buffers","byteLength","bufferRegions","values","assembleUnion","typeIds","valueOffsets","mode","Sparse","assembleNestedVector","Dense","maxChildTypeId","reduce","x","y","Math","max","childLengths","Int32Array","childOffsets","fill","shiftedOffsets","unshiftedOffsets","typeId","shift","index","child","childIndex","numChildren","childLength","min","slice","assembleBoolVector","assembleFlatVector","subarray","stride","assembleFlatListVector","firstOffset","lastOffset","assembleListVector","map","_","i","filter","Boolean","prototype","visitBool","visitInt","visitFloat","visitUtf8","visitBinary","visitFixedSizeBinary","visitDate","visitTimestamp","visitTime","visitDecimal","visitList","visitStruct","visitUnion","visitInterval","visitFixedSizeList","visitMap"],"sources":["C:\\Users\\emclulo\\Downloads\\GitHub\\Banco_de_Dados--Associacao_Sindrome_de_Down\\timetable_canvas\\frontend\\node_modules\\apache-arrow\\src\\visitor\\vectorassembler.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The ASF licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\nimport { Data } from '../data.js';\r\nimport { Vector } from '../vector.js';\r\nimport { Visitor } from '../visitor.js';\r\nimport { Type, UnionMode } from '../enum.js';\r\nimport { RecordBatch } from '../recordbatch.js';\r\nimport { TypeToDataType } from '../interfaces.js';\r\nimport { rebaseValueOffsets } from '../util/buffer.js';\r\nimport { packBools, truncateBitmap } from '../util/bit.js';\r\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.js';\r\nimport {\r\n    DataType, Dictionary,\r\n    Float, Int, Date_, Interval, Time, Timestamp, Union,\r\n    Bool, Null, Utf8, Binary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct,\r\n} from '../type.js';\r\n\r\n/** @ignore */\r\nexport interface VectorAssembler extends Visitor {\r\n    visit<T extends DataType>(node: Vector<T> | Data<T>): this;\r\n    visitMany<T extends DataType>(nodes: readonly Data<T>[]): this[];\r\n    getVisitFn<T extends Type>(node: T): (data: Data<TypeToDataType<T>>) => this;\r\n    getVisitFn<T extends DataType>(node: Vector<T> | Data<T> | T): (data: Data<T>) => this;\r\n\r\n    visitBool<T extends Bool>(data: Data<T>): this;\r\n    visitInt<T extends Int>(data: Data<T>): this;\r\n    visitFloat<T extends Float>(data: Data<T>): this;\r\n    visitUtf8<T extends Utf8>(data: Data<T>): this;\r\n    visitBinary<T extends Binary>(data: Data<T>): this;\r\n    visitFixedSizeBinary<T extends FixedSizeBinary>(data: Data<T>): this;\r\n    visitDate<T extends Date_>(data: Data<T>): this;\r\n    visitTimestamp<T extends Timestamp>(data: Data<T>): this;\r\n    visitTime<T extends Time>(data: Data<T>): this;\r\n    visitDecimal<T extends Decimal>(data: Data<T>): this;\r\n    visitList<T extends List>(data: Data<T>): this;\r\n    visitStruct<T extends Struct>(data: Data<T>): this;\r\n    visitUnion<T extends Union>(data: Data<T>): this;\r\n    visitInterval<T extends Interval>(data: Data<T>): this;\r\n    visitFixedSizeList<T extends FixedSizeList>(data: Data<T>): this;\r\n    visitMap<T extends Map_>(data: Data<T>): this;\r\n}\r\n\r\n/** @ignore */\r\nexport class VectorAssembler extends Visitor {\r\n\r\n    /** @nocollapse */\r\n    public static assemble<T extends Vector | RecordBatch>(...args: (T | T[])[]) {\r\n        const unwrap = (nodes: (T | T[])[]): Data[] =>\r\n            nodes.flatMap((node: T | T[]) => Array.isArray(node) ? unwrap(node) :\r\n                (node instanceof RecordBatch) ? node.data.children : node.data);\r\n        const assembler = new VectorAssembler();\r\n        assembler.visitMany(unwrap(args));\r\n        return assembler;\r\n    }\r\n\r\n    private constructor() { super(); }\r\n\r\n    public visit<T extends DataType>(data: Vector<T> | Data<T>): this {\r\n        if (data instanceof Vector) {\r\n            this.visitMany(data.data);\r\n            return this;\r\n        }\r\n        const { type } = data;\r\n        if (!DataType.isDictionary(type)) {\r\n            const { length, nullCount } = data;\r\n            if (length > 2147483647) {\r\n                /* istanbul ignore next */\r\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\r\n            }\r\n            if (!DataType.isNull(type)) {\r\n                addBuffer.call(this, nullCount <= 0\r\n                    ? new Uint8Array(0) // placeholder validity buffer\r\n                    : truncateBitmap(data.offset, length, data.nullBitmap)\r\n                );\r\n            }\r\n            this.nodes.push(new FieldNode(length, nullCount));\r\n        }\r\n        return super.visit(data);\r\n    }\r\n\r\n    public visitNull<T extends Null>(_null: Data<T>) {\r\n        return this;\r\n    }\r\n\r\n    public visitDictionary<T extends Dictionary>(data: Data<T>) {\r\n        // Assemble the indices here, Dictionary assembled separately.\r\n        return this.visit(data.clone(data.type.indices));\r\n    }\r\n\r\n    public get nodes() { return this._nodes; }\r\n    public get buffers() { return this._buffers; }\r\n    public get byteLength() { return this._byteLength; }\r\n    public get bufferRegions() { return this._bufferRegions; }\r\n\r\n    protected _byteLength = 0;\r\n    protected _nodes: FieldNode[] = [];\r\n    protected _buffers: ArrayBufferView[] = [];\r\n    protected _bufferRegions: BufferRegion[] = [];\r\n}\r\n\r\n/** @ignore */\r\nfunction addBuffer(this: VectorAssembler, values: ArrayBufferView) {\r\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\r\n    this.buffers.push(values);\r\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\r\n    this._byteLength += byteLength;\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleUnion<T extends Union>(this: VectorAssembler, data: Data<T>) {\r\n    const { type, length, typeIds, valueOffsets } = data;\r\n    // All Union Vectors have a typeIds buffer\r\n    addBuffer.call(this, typeIds);\r\n    // If this is a Sparse Union, treat it like all other Nested types\r\n    if (type.mode === UnionMode.Sparse) {\r\n        return assembleNestedVector.call(this, data);\r\n    } else if (type.mode === UnionMode.Dense) {\r\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\r\n        if (data.offset <= 0) {\r\n            // If the Vector hasn't been sliced, write the existing valueOffsets\r\n            addBuffer.call(this, valueOffsets);\r\n            // We can treat this like all other Nested types\r\n            return assembleNestedVector.call(this, data);\r\n        } else {\r\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\r\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\r\n            // Union typeIds are not necessary 0-indexed\r\n            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\r\n            const childLengths = new Int32Array(maxChildTypeId + 1);\r\n            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\r\n            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\r\n            const shiftedOffsets = new Int32Array(length);\r\n            // If we have a non-zero offset, then the value offsets do not start at\r\n            // zero. We must a) create a new offsets array with shifted offsets and\r\n            // b) slice the values array accordingly\r\n            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\r\n            for (let typeId, shift, index = -1; ++index < length;) {\r\n                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\r\n                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];\r\n                }\r\n                shiftedOffsets[index] = unshiftedOffsets[index] - shift;\r\n                ++childLengths[typeId];\r\n            }\r\n            addBuffer.call(this, shiftedOffsets);\r\n            // Slice and visit children accordingly\r\n            for (let child: Data | null, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\r\n                if (child = data.children[childIndex]) {\r\n                    const typeId = type.typeIds[childIndex];\r\n                    const childLength = Math.min(length, childLengths[typeId]);\r\n                    this.visit(child.slice(childOffsets[typeId], childLength));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleBoolVector<T extends Bool>(this: VectorAssembler, data: Data<T>) {\r\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\r\n    let values: Uint8Array;\r\n    if (data.nullCount >= data.length) {\r\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\r\n        return addBuffer.call(this, new Uint8Array(0));\r\n    } else if ((values = data.values) instanceof Uint8Array) {\r\n        // If values is already a Uint8Array, slice the bitmap (fast path)\r\n        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\r\n    }\r\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\r\n    // values as bools and re-pack them into a Uint8Array. This code isn't\r\n    // reachable unless you're trying to manipulate the Data internals,\r\n    // we're only doing this for safety.\r\n    /* istanbul ignore next */\r\n    return addBuffer.call(this, packBools(data.values));\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleFlatVector<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval>(this: VectorAssembler, data: Data<T>) {\r\n    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleFlatListVector<T extends Utf8 | Binary>(this: VectorAssembler, data: Data<T>) {\r\n    const { length, values, valueOffsets } = data;\r\n    const firstOffset = valueOffsets[0];\r\n    const lastOffset = valueOffsets[length];\r\n    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\r\n    // Push in the order FlatList types read their buffers\r\n    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\r\n    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\r\n    return this;\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleListVector<T extends Map_ | List | FixedSizeList>(this: VectorAssembler, data: Data<T>) {\r\n    const { length, valueOffsets } = data;\r\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\r\n    if (valueOffsets) {\r\n        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\r\n    }\r\n    // Then insert the List's values child\r\n    return this.visit(data.children[0]);\r\n}\r\n\r\n/** @ignore */\r\nfunction assembleNestedVector<T extends Struct | Union>(this: VectorAssembler, data: Data<T>) {\r\n    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\r\n}\r\n\r\nVectorAssembler.prototype.visitBool = assembleBoolVector;\r\nVectorAssembler.prototype.visitInt = assembleFlatVector;\r\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\r\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\r\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\r\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\r\nVectorAssembler.prototype.visitDate = assembleFlatVector;\r\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\r\nVectorAssembler.prototype.visitTime = assembleFlatVector;\r\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\r\nVectorAssembler.prototype.visitList = assembleListVector;\r\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\r\nVectorAssembler.prototype.visitUnion = assembleUnion;\r\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\r\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\r\nVectorAssembler.prototype.visitMap = assembleListVector;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}